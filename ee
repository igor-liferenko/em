#!/usr/bin/perl -CA

# TODO: use https://github.com/hughbarney/zepto

use strict;

$| = 1;
$_ = '' for my (
    $x,           $y,           $topline,     $lastxsearch, $lastysearch, $ins,
    $forceupdate, $cols,        $rows,        $search,      $status,      $filename,
    $dos,         $center_line, $lasttopline, $lastnrlines, $searchx,     $stty
);

my @lines;

# catch terminal resize
$SIG{WINCH} = sub {
    get_terminal_size();
    $forceupdate = 1;
    draw();
};

init();
load();
run();

sub init {
    $lastxsearch = -1;
    $forceupdate = 1;
    $ins         = 1;
    $searchx     = 0;
}

sub get_terminal_size {
    ( $rows, $cols ) = split( /\s+/, `stty size` );
    $rows -= 1;
}

sub load {
    my $regexp = qr/\+(\d+)/;
    ($filename) = grep { $_ !~ $regexp } @ARGV;

    if ( !open( FILE, $filename ) ) {
        @lines = ('');
        return;
    }
    binmode(FILE, ':utf8');
    foreach my $line (<FILE>) {
        $dos = 1 if ( $line =~ m/\r\n$/ );
        $line =~ s/\r?\n$//;
        push( @lines, $line );
    }

    close(FILE);
    $dos = $dos;
    return 1;
}

sub save {
    my $savefilename = $filename || input('Filename');

    if ( !open( FILE, ">$savefilename" ) ) {
        $status = "Save failed $!";
        return;
    }
    binmode(FILE, ':utf8');
    my $count = 0;
    foreach my $line (@lines) {
        print FILE $line . ( $dos ? "\r\n" : "\n" );
        $count++;
    }
    close(FILE);

    $status = "Saved $count lines.";
    footer();
    $filename = $savefilename;
    return 1;
}

sub run {
    get_terminal_size();
    my $regexp = qr/\+(\d+)/;
    my ($center_line_arg) = grep { $_ =~ $regexp } @ARGV;
    my ($center_line) = $center_line_arg =~ $regexp;
    $topline = $center_line - ( $rows / 2 ) - 1;
    binmode(STDIN, ':utf8');
    binmode(STDOUT, ':utf8');

    # https://gavenkoa-tips.readthedocs.io/en/latest/vt100.html
    print "\e7"; # save cursor position and attributes
    print "\e[?47h"; # switch to the alternate screen
    ReadMode(5);
    my $key;

    while (1) {
        $lasttopline = $topline;
        $lastnrlines = get_nrlines();
        last if ( !dokey($key) );
        draw();
        move();
        $key = ReadKey();
    }

    ReadMode(0);
    print "\e[2J"; # clear entire screen (the alternate screen)
    print "\e[?47l"; # switch back to the normal screen
    print "\e8"; # restore cursor position and attributes
}

sub get_nrlines {
    return scalar(@lines);
}

sub get_escape_sequence {
    my ( $esc, $pos );
    while ( my $key = ReadKey() ) {
        $pos++;
        $esc .= $key;
        next if ( $pos == 1 && $key == 'O' );
        last if ( $key =~ /[a-z~]/i );
    }

    return $esc;
}

sub dokey {
    my ($key) = @_;
    my $ctrl = ord($key);
    if    ( $ctrl == 26 )  { return if ( save() ) }   # Ctrl+z
    elsif ( $ctrl == 27 ) {                           # escape code
        my $esc = get_escape_sequence();

        if    ( $esc eq '[A' ) { moveup(1) }          # up
        elsif ( $esc eq '[B' ) {
            movedown(1);
        }                                             # down
        elsif ( $esc eq '[5~' ) { moveup($rows) }     # pgup
        elsif ( $esc eq '[6~' ) { movedown($rows) }   # pgdn
        elsif ( $esc eq '[C' )  { moveright(1) }      # right
        elsif ( $esc eq '[D' )  { moveleft(1) }       # left
        elsif ( $esc eq '[3~' ) { delat() }           # del
        elsif ( $esc eq '[H' ) {                     # home
            moveup( current_line_number() );
        }
        elsif ( $esc eq '[F' ) {                     # end
            movedown( get_nrlines() - current_line_number() );
        }
        elsif ( $esc eq '[2~' ) {                     # insert
            $ins = !$ins;
        }
        elsif ( $esc eq 'OP' ) {
          setat(chr(0x00ab));
          moveright(1);
        }
        elsif ( $esc eq 'OQ' ) {
          setat(chr(0x00bb));
          moveright(1);
        }
    }
    elsif ( $ctrl == 8 ) {            # BACKSPACE
        backspaceat();
        moveleft(1);
    }
    elsif ( $ctrl == 13 ) {            # newline
        newlineat();
        movedown(1);
        $x = 0;
    }
    elsif ( $ctrl == 11 ) {                           # Ctrl+K
        delteol();
    }
    elsif ( $ctrl == 19 ) {                            # Ctrl+S
        search();
    }
    elsif ( $ctrl == 9 || ( $ctrl >= 32 && $ctrl <= 126 ) || $ctrl > 127 ) {
        setat($key);
        moveright(1);
    }
    return 1;
}

sub moveright {
    my ($amount) = @_;
    $x += $amount;
    if ( $x > length( line() ) ) {
        if ( current_line_number() < get_nrlines() - 1 ) {
            $x = 0;
            movedown(1);
        }
    }
}

sub moveleft {
    my ($amount) = @_;
    $x -= $amount;

    if ( $x < 0 ) {
        $x = length2( line(-1) );
        moveup(1);
    }
}

sub moveup {
    my ($amount) = @_;
    $y -= $amount;

    # check for topline, move up
    if ( $y < 0 ) {
        $topline += $y;
        $y = 0;
    }
}

sub movedown {
    my ($amount) = @_;
    my $tempy = $y + $amount;

    my $nrlines = get_nrlines();

    # move down
    if ( ( $topline + $tempy ) >= $nrlines ) {
        $topline = $nrlines - $rows;
        $topline = 0 if ( $topline < 0 );
        $tempy   = $nrlines - $topline - 1;
    }
    elsif ( $tempy >= $rows ) {
        $topline += ( $tempy - $rows + 1 );
        $tempy = $rows - 1;
    }

    # check for corsormovement beyond line length2
    $y = $tempy;
}

sub search {
    $search = input('search') if ( !$search );
    my $found;
    for ( my $i = current_line_number() ; $i < get_nrlines() ; $i++ ) {
        $found = index( lc( $lines[$i] ), lc($search), $searchx );
        if ( $found != -1 ) {
            $x       = $found;
            $searchx = $found + 1;
            $y       = 0;
            $topline = $i;
            move();
            last;
        }
        else { $searchx = 0 }
    }
    if ( $found == -1 ) { movedown( get_nrlines() - current_line_number() ); $status = 'Reached end of file.'; $search = '' }
}

sub delteol {
    line( 0, substr( line(), 0, $x ) );
    delat() if ( $x == 0 );
}

sub newlineat {
    my $begin = substr( line(), 0, $x );
    my $end   = substr( line(), $x );

    line( 0, $begin );
    splice( @lines, current_line_number() + 1, 0, $end );
}

sub delat {
    my $len = length2( line() );
    if ( $x < $len ) {
        my $begin = substr( line(), 0, $x );
        my $end = substr( line(), $x + 1 );
        line( 0, $begin . $end );
    }
    else {
        line( 0, line() . line(1) );
        splice( @lines, current_line_number() + 1, 1 );
    }
}

sub backspaceat {
    if ( $x <= 0 && $y > 0 ) {
        $x = length2( line(-1) ) + 1;
        line( -1, line(-1) . line() );
        splice( @lines, current_line_number(), 1 );
        moveup(1);
    }
    else {
        my $begin = substr( line(), 0, $x ? $x - 1 : 0 );
        my $end   = substr( line(), $x );
        my $line  = $begin . $end;
        line( 0, $line );
    }
}

sub line {
    my ( $offset, $text ) = @_;
    $offset ||= 0;
    my $pos = current_line_number() + $offset;

    if ( defined($text) ) {
        $lines[$pos] = $text;
    }
    else {
        return $lines[$pos];
    }
}

sub setat {
    my ($key) = @_;

    my $begin = substr( line(), 0, $x );
    my $end = substr( line(), $ins ? $x : $x + 1 );
    line( 0, $begin . $key . $end );
}

sub error {
    die "failed: @_";
}

sub clear {
    print "\e[2J";
}

sub footer {
    absmove( 0, $rows + 1 );
    print inverse( ' ' x ( $cols - 1 ) );
    absmove( 0, $rows + 1 );
    print inverse( '[' . ( $filename || 'Untitled' ) . ']' . ' ' . ( $status || '' ) );

    my $xy = ''
      . ( $dos ? 'DOS' : 'UNIX' ) . ' '
      . ( $ins ? 'INS' : '' ) . ' [ '
      . ( $x + 1 ) . '/'
      . ( length( line() ) + 1 ) . ':'
      . ( current_line_number() + 1 ) . '/'
      . get_nrlines() . ' ]';
    absmove( $cols - length2($xy), $rows + 1 );
    print inverse($xy);
}

sub current_line_number {
    return $topline + $y;
}

sub draw {
    my $len = length( line() );
    $x = $len if ( $x > $len );
    if ( $topline < 0 ) {
        $topline = 0;
        $x       = 0;
    }

    # update only current line
    if (   $lasttopline == $topline
        && $lastnrlines == get_nrlines()
        && !$forceupdate )
    {
        absmove( 0, $y + 1 );
        print "\e[K";
        drawline( current_line_number() );
    }
    else    # update screen
    {
        clear();
        absmove( 0, 1 );

        for ( my $pos = $topline ; $pos < $topline + $rows && $pos < get_nrlines() ; $pos++ ) {
            drawline($pos);
        }
        $forceupdate = 0;
    }
    footer();
}

sub drawline {
    my ($pos) = @_;
    my $line = $lines[$pos];

    # expand tabs

    1 while $line =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
    my $realx = getrealx( $lines[$pos] );
    if ( $realx < $cols - 1 ) {
        $line = substr( $line, 0, $cols - 1 );
    }
    else {
        $line = substr( $line, $realx - ( $cols - 1 ), $cols - 1 );
    }

    print $line . "\r\n";
}

sub absmove {
    my ( $x, $y ) = @_;
    print "\e[" . $y . ';' . $x . 'f';
}

sub getrealx {
    my ($line) = @_;
    return length2( substr( $line, 0, $x ) );
}

sub move {
    my $realx = getrealx( line() );
    print "\e[" . ( $y + 1 ) . ';' . ( $realx + 1 ) . 'f';
}

sub inverse {
    my ($text) = @_;
    return "\e[7m" . $text . "\e[m";
}

sub input {
    my ($text) = @_;
    absmove( 0, $rows + 1 );
    print inverse( ' ' x ( $cols - 1 ) );
    absmove( 0, $rows + 1 );
    print "\e[7m";
    print "$text: ";

    ReadMode(0);
    my $result = ReadLine();
    ReadMode(5);

    $result =~ s/\r?\n$//;

    print "\e[m";
    $forceupdate = 1;
    return $result;
}

sub length2 {

    # calculate length with tabs expanded
    my ($text) = @_;
    1 while $text =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
    return length($text);
}

sub ReadKey {
    my $key = '';
    read( STDIN, $key, 1 );
    return $key;
}

sub ReadLine {
    return <STDIN>;
}

sub ReadMode {
    my ($mode) = @_;
    if ( $mode == 5 ) {
        $stty = `stty -g`;
        chomp($stty);
        system( 'stty', 'raw', '-echo' );
    }
    elsif ( $mode == 0 ) {
        system( 'stty', $stty );
    }
}

/* Reverse scan for start of logical line containing offset */
point_t lnstart(buffer_t *bp, register point_t off)
{
	register char_t *p;
	do
		p = ptr(bp, --off);
	while (bp->b_buf < p && *p != '\n');
	return (bp->b_buf < p ? ++off : 0);
}

point_t lnfinish(buffer_t *bp, register point_t off)
{
  if (off == pos(bp, bp->b_ebuf)) return off;
  register char_t *p;
  do
    p = ptr(bp, off++);
  while (bp->b_ebuf > p && *p != '\n');
  return (bp->b_ebuf > p ? --off : pos(bp, bp->b_ebuf));
}

/* Forward scan for start of logical line segment containing 'finish' */
point_t segstart(buffer_t *bp, point_t start, point_t finish)
{
	char_t *p;
	int c = 0;
	point_t scan = start;

	while (scan < finish) {
		p = ptr(bp, scan);
		if (*p == '\n') {
			c = 0;
			start = scan + 1;
		} else if (COLS <= c) {
			c = 0;
			start = scan;
		}
		++scan;
		c += *p == '\t' ? 8 - (c & 7) : 1;
	}
	return (c < COLS ? start : finish);
}

/* Forward scan for start of logical line segment following 'finish' */
point_t segnext(buffer_t *bp, point_t start, point_t finish)
{
	char_t *p;
	int c = 0;

	point_t scan = segstart(bp, start, finish);
	for (;;) {
		p = ptr(bp, scan);
		if (bp->b_ebuf <= p || COLS <= c) break;
		++scan;
		if (*p == '\n') break;
		c += *p == '\t' ? 8 - (c & 7) : 1;
	}
	return (p < bp->b_ebuf ? scan : pos(bp, bp->b_ebuf));
}

/* Move up one screen line */
point_t upup(buffer_t *bp, point_t off)
{
	point_t curr = lnstart(bp, off);
	point_t seg = segstart(bp, curr, off);
	if (curr < seg)
		off = segstart(bp, curr, seg-1);
	else
		off = segstart(bp, lnstart(bp,curr-1), curr-1);
	return (off);
}

/* Move down one screen line */
point_t dndn(buffer_t *bp, point_t off) { return (segnext(bp, lnstart(bp,off), off)); }

/* Return the offset of a column on the specified line */
point_t lncolumn(buffer_t *bp, point_t offset, int column)
{
	int c = 0;
	char_t *p;
	while ((p = ptr(bp, offset)) < bp->b_ebuf && *p != '\n' && c < column) {
		c += *p == '\t' ? 8 - (c & 7) : 1;
		++offset;
	}
	return (offset);
}
void top() { curbp->b_point = 0; }
void bottom() {	curbp->b_epage = curbp->b_point = pos(curbp, curbp->b_ebuf); }
void left() { if (0 < curbp->b_point) --curbp->b_point; }
void right() { if (curbp->b_point < pos(curbp, curbp->b_ebuf)) ++curbp->b_point; }
void up() { curbp->b_point = lncolumn(curbp, upup(curbp, curbp->b_point),curbp->b_col); }
void down() { curbp->b_point = lncolumn(curbp, dndn(curbp, curbp->b_point),curbp->b_col); }
void lnbegin() { curbp->b_point = segstart(curbp, lnstart(curbp,curbp->b_point), curbp->b_point); }
void lnbeginning() { curbp->b_point = lnstart(curbp,curbp->b_point); }
void lnending() { curbp->b_point = lnfinish(curbp,curbp->b_point); }
void quit() { done = 1; }
void lnend()
{
	point_t before = segstart(curbp, lnstart(curbp,curbp->b_point), curbp->b_point);
	curbp->b_point = dndn(curbp, curbp->b_point);
	point_t after = segstart(curbp, lnstart(curbp,curbp->b_point), curbp->b_point);
	if (before != after) /* without this condition, when we are on last line, cursor will
		                    be on last char instead of after it (in file that does not
		                    end with |'\n'|) */
	  left();
}

void pgdown()
{
	curbp->b_page = curbp->b_point = upup(curbp, curbp->b_epage);
	while (0 < curbp->b_row--)
		down();
	curbp->b_epage = pos(curbp, curbp->b_ebuf);
}

void pgup()
{
	int i = curbp->w_rows;
	while (0 < --i) {
		curbp->b_page = upup(curbp, curbp->b_page);
		up();
	}
}

